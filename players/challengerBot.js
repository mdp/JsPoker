// Generated by CoffeeScript 1.6.2
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module.exports = (function() {
    function _Class() {
      var i, p, _i, _j, _len, _ref;

      _ref = this.posNames;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        p = _ref[i];
        this.pos[p] = i;
      }
      for (i = _j = 2; _j <= 9; i = ++_j) {
        this.handVals['' + i] = i;
      }
      this.state = {
        bb: null,
        betting: null,
        bettingRound: 0,
        chips: 0,
        community: null,
        communitySuits: null,
        communityVals: null,
        faces: null,
        hand: null,
        monster: false,
        pair: false,
        playable: false,
        pokerHand: null,
        pokerHandComm: null,
        pokerVals: null,
        pokerValsComm: null,
        pos: null,
        previousRound: null,
        round: null,
        suits: null,
        vals: [0, 0]
      };
    }

    _Class.prototype.handVals = {
      T: 10,
      J: 11,
      Q: 12,
      K: 13,
      A: 14
    };

    _Class.prototype.info = {
      name: 'SneakyCharlie',
      email: 'lstoakes@gmail.com',
      btcWallet: '1NtpjxBCDi1uNHJHBnXkNh41foxWxFNzvn'
    };

    _Class.prototype.pokerHand = {
      straightFlush: 8,
      fourKind: 7,
      fullHouse: 6,
      flush: 5,
      straight: 4,
      threeKind: 3,
      twoPair: 2,
      pair: 1,
      highCard: 0
    };

    _Class.prototype.pokerHandNames = ['high card', 'pair', 'two pair', 'three of a kind', 'straight', 'flush', 'full house', 'four of a kind', 'straight flush'];

    _Class.prototype.pos = {};

    _Class.prototype.posNames = ['button', 'sb', 'bb', 'utg', 'mp1', 'mp', 'hj', 'co'];

    _Class.prototype.preflopRanges = [['A8s+', 'KQ', 'KJ', 'QJ', '22+'], ['AQs', 'AK', '77+'], ['AQs', 'AK', '77+'], ['AQs', 'AK', '77+'], ['AJ+', '55+'], ['AJ+', 'KQs', '22+'], ['AJ+', 'KQ', 'QJ', '22+'], ['AJ+', 'KQ', 'QJ', '22+']];

    _Class.prototype.specialBet = {
      fold: -1,
      checkFold: 0
    };

    _Class.prototype.state = null;

    _Class.prototype.analyse = function(game) {
      var allSuits, allVals, betting, cards, chips, classified, classifiedComm, community, currPos, faces, hand, highVal, i, players, position, range, round, s, suits, superior, v, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;

      betting = game.betting, community = game.community, (_ref = game.self, cards = _ref.cards, chips = _ref.chips, position = _ref.position), players = game.players, round = game.state;
      this.state.betting = betting;
      this.state.community = community.sort().join('');
      this.state.communitySuits = ((function() {
        var _i, _len, _ref1, _results;

        _ref1 = this.state.community.slice(1);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i += 2) {
          s = _ref1[_i];
          _results.push(s);
        }
        return _results;
      }).call(this)).sort().join('');
      this.state.communityVals = (function() {
        var _i, _len, _ref1, _results;

        _ref1 = this.state.community;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i += 2) {
          v = _ref1[_i];
          _results.push(this.handVals[v]);
        }
        return _results;
      }).call(this);
      this.state.hand = hand = cards.sort().join('');
      this.state.faces = faces = hand[0] + hand[2];
      this.state.suits = suits = hand[1] + hand[3];
      this.state.chips = chips;
      this.state.vals = [this.handVals[faces[0]], this.handVals[faces[1]]];
      this.sortNum(this.state.vals);
      this.state.pos = currPos = this.calcPos(players.length, position);
      this.state.bb = this.getBigBlind(players);
      this.state.playable = false;
      this.state.previousRound = this.state.round;
      this.state.round = round;
      if (this.state.previousRound === round) {
        this.state.bettingRound++;
      } else {
        this.state.bettingRound = 1;
      }
      this.state.pair = faces[0] === faces[1];
      if (round === 'pre-flop') {
        this.state.monster = faces === 'AA' || faces === 'KK';
        _ref1 = this.preflopRanges[currPos];
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          range = _ref1[_i];
          if (!(this.inRange(range))) {
            continue;
          }
          this.state.playable = true;
          break;
        }
        return _results;
      } else {
        allSuits = this.state.suits.concat(this.state.communitySuits);
        allVals = this.state.vals.concat(this.state.communityVals);
        classified = this.classifyHand(allSuits, allVals);
        this.state.pokerHand = classified.type;
        this.state.pokerVals = classified.vals;
        classifiedComm = this.classifyHand(this.state.communitySuits, this.state.communityVals);
        this.state.pokerHandComm = classifiedComm.type;
        this.state.pokerValsComm = classifiedComm.vals;
        superior = this.state.pokerHand >= this.pokerHand.threeKind;
        superior = superior && this.state.pokerHand >= this.state.pokerHandComm;
        if (superior && this.state.pokerHand === this.state.pokerHandComm) {
          superior = false;
          _ref2 = this.state.pokerVals;
          for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
            highVal = _ref2[i];
            if (!(highVal > this.state.pokerValsComm[i])) {
              continue;
            }
            superior = true;
            break;
          }
        }
        this.state.playable = superior;
        return this.state.monster = superior && this.state.pokerHand >= this.pokerHand.fullHouse;
      }
    };

    _Class.prototype.calcPos = function(playerCount, positionId) {
      var fromEnd;

      positionId++;
      positionId %= playerCount;
      if (playerCount === 2 && positionId === 1) {
        return this.pos.bb;
      }
      if (positionId < 4) {
        return positionId;
      }
      fromEnd = playerCount - positionId - 1;
      if (fromEnd < 2) {
        return [this.pos.co, this.pos.hj][fromEnd];
      }
      if (positionId === 4) {
        return this.pos.mp1;
      } else {
        return this.pos.mp;
      }
    };

    _Class.prototype.classifyHand = function(suits, vals) {
      var flush, fours, i, len, max, ofKind, straight, suitHash, threes, twos, val, valid, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _ref3;

      flush = this.containsFlush(suits);
      straight = this.containsStraight(vals);
      if (flush && straight) {
        valid = true;
        if (vals.length > 5) {
          suitHash = {};
          for (i = _i = 0, _len = vals.length; _i < _len; i = ++_i) {
            val = vals[i];
            suitHash[val] = suits[i];
          }
          suitHash[1] = suitHash[14];
          for (val = _j = straight, _ref = straight - 5; straight <= _ref ? _j < _ref : _j > _ref; val = straight <= _ref ? ++_j : --_j) {
            if (!(suitHash[val] !== flush)) {
              continue;
            }
            valid = false;
            break;
          }
        }
        if (valid) {
          return {
            type: this.pokerHand.straightFlush,
            vals: [straight]
          };
        }
      }
      ofKind = this.containsNofaKind(vals);
      if ((fours = (_ref1 = ofKind.countToVals) != null ? _ref1[4] : void 0) != null) {
        return {
          type: this.pokerHand.fourKind,
          vals: fours
        };
      }
      twos = (_ref2 = ofKind.countToVals) != null ? _ref2[2] : void 0;
      threes = (_ref3 = ofKind.countToVals) != null ? _ref3[3] : void 0;
      if ((twos != null) && (threes != null)) {
        return {
          type: this.pokerHand.fullHouse,
          vals: [this.maxArr(threes), this.maxArr(twos)]
        };
      }
      if ((threes != null) && (len = threes.length) > 1) {
        this.sortNum(threes);
        return {
          type: this.pokerHand.fullHouse,
          vals: [threes[len - 1], threes[len - 2]]
        };
      }
      if (flush) {
        max = -1;
        for (i = _k = 0, _len1 = vals.length; _k < _len1; i = ++_k) {
          val = vals[i];
          if (suits[i] === flush && val > max) {
            max = val;
          }
        }
        return {
          type: this.pokerHand.flush,
          vals: [max]
        };
      }
      if (straight) {
        return {
          type: this.pokerHand.straight,
          vals: [straight]
        };
      }
      if (threes != null) {
        return {
          type: this.pokerHand.threeKind,
          vals: [this.maxArr(threes)]
        };
      }
      if (twos != null) {
        len = twos.length;
        if (len === 1) {
          return {
            type: this.pokerHand.pair,
            vals: twos
          };
        }
        this.sortNum(twos);
        return {
          type: this.pokerHand.twoPair,
          vals: [twos[len - 1], twos[len - 2]]
        };
      }
      if (!ofKind) {
        return {
          type: this.pokerHand.highCard,
          vals: [this.maxArr(vals)]
        };
      }
      throw new Error('Invalid ofKind state.');
    };

    _Class.prototype.containsFlush = function(suits) {
      var countsBySuit, n, suit, _i, _len, _ref;

      if (suits === '') {
        return false;
      }
      countsBySuit = {};
      for (_i = 0, _len = suits.length; _i < _len; _i++) {
        suit = suits[_i];
        n = (_ref = countsBySuit[suit]) != null ? _ref : 0;
        countsBySuit[suit] = ++n;
        if (n === 5) {
          return suit;
        }
      }
      return false;
    };

    _Class.prototype.containsNofaKind = function(vals) {
      var count, countToVals, needsSort, ret, tmp, val, _i, _len, _ref;

      tmp = new Uint8Array(14 + 1);
      ret = null;
      for (_i = 0, _len = vals.length; _i < _len; _i++) {
        val = vals[_i];
        count = ++tmp[val];
        if (count > 1) {
          if (ret == null) {
            ret = {
              valToCount: {},
              countToVals: {}
            };
          }
          ret.valToCount[val] = count;
        }
      }
      if (ret == null) {
        return false;
      }
      _ref = ret.valToCount;
      for (val in _ref) {
        count = _ref[val];
        needsSort = false;
        val = parseInt(val, 10);
        countToVals = ret.countToVals[count];
        if (countToVals == null) {
          ret.countToVals[count] = countToVals = [];
        } else {
          needsSort = true;
        }
        countToVals.push(val);
        if (needsSort) {
          this.sortNum(countToVals);
        }
      }
      return ret;
    };

    _Class.prototype.containsStraight = function(vals) {
      var hits, prev, val, _i, _j, _len, _len1, _ref;

      if (vals.length < 5) {
        return false;
      }
      for (_i = 0, _len = vals.length; _i < _len; _i++) {
        val = vals[_i];
        if (!(val === this.handVals.A)) {
          continue;
        }
        vals = vals.concat(1);
        break;
      }
      this.sortNum(vals);
      hits = 1;
      prev = vals[0];
      _ref = vals.slice(1);
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        val = _ref[_j];
        if (val === prev + 1) {
          hits++;
        } else if (val !== prev) {
          hits = 1;
        }
        if (hits === 5) {
          return val;
        }
        prev = val;
      }
      return false;
    };

    _Class.prototype.getBigBlind = function(players) {
      var p, ret, _i, _len;

      ret = 0;
      for (_i = 0, _len = players.length; _i < _len; _i++) {
        p = players[_i];
        if (p.blind > ret) {
          ret = p.blind;
        }
      }
      return ret;
    };

    _Class.prototype.inRange = function(range) {
      var actual, expected, expectedVals, pair, r, rangePair, rangeSuited, suits, vals, _ref;

      _ref = this.state, pair = _ref.pair, suits = _ref.suits, vals = _ref.vals;
      rangeSuited = __indexOf.call(range.slice(2), 's') >= 0;
      if (rangeSuited && (pair || suits[0] !== suits[1])) {
        return false;
      }
      expectedVals = (function() {
        var _i, _len, _ref1, _results;

        _ref1 = range.slice(0, 2);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          r = _ref1[_i];
          _results.push(this.handVals[r]);
        }
        return _results;
      }).call(this);
      this.sortNum(expectedVals);
      rangePair = range[0] === range[1];
      if (rangePair) {
        actual = vals[0];
        if (actual !== vals[1]) {
          return false;
        }
        expected = expectedVals[0];
        return actual >= expected;
      }
      return vals[0] >= expectedVals[0] && vals[1] >= expectedVals[1];
    };

    _Class.prototype.maxArr = function(arr) {
      return Math.max.apply(null, arr);
    };

    _Class.prototype.preflopBet = function() {
      if (this.state.monster) {
        return this.state.chips;
      } else if (this.state.playable) {
        if (this.state.bettingRound === 1) {
          return 8 * this.state.betting.raise;
        } else {
          return this.state.betting.call;
        }
      }
      return this.specialBet.checkFold;
    };

    _Class.prototype.postflopBet = function() {
      if (!this.state.playable) {
        return this.specialBet.checkFold;
      }
      if (this.state.monster) {
        return this.state.chips;
      }
      if (this.state.bettingRound === 1) {
        return 8 * this.state.betting.raise;
      } else {
        return this.state.betting.call;
      }
    };

    _Class.prototype.sortNum = function(ns) {
      return ns.sort(function(a, b) {
        return a - b;
      });
    };

    _Class.prototype.update = function(game) {
      this.analyse(game);
      switch (this.state.round) {
        case 'complete':
          return null;
        case 'pre-flop':
          return this.preflopBet();
        default:
          return this.postflopBet();
      }
    };

    return _Class;

  })();

}).call(this);
